<!DOCTYPE html>
<html>
  <head>
    <title>
      Secure Element API
    </title>
    <meta charset='utf-8'>
    <link href="http://www.globalplatform.org/favicon.ico" rel="icon" type=
    "image/x-icon">
    <script src='http://www.w3.org/Tools/respec/respec-w3c-common' async=""
    class='remove'>
</script>
    <script class='remove'>
/*Respec configuration*/
    var 
    yearStart = "2015",
    yearNow = "" + new Date().getFullYear(),
    copyrightYears = (yearStart === yearNow) ? yearStart : yearStart + '-' + yearNow,
    respecConfig = {

          // specification status (e.g. WD, LCWD, NOTE, etc.). If in doubt use ED.
          specStatus:           "base",

          // GlobalPlatform Logo
          logos: [
             {
                src: 'http://www.globalplatform.org/images/gplogo_2010.gif',
                href: "http://www.globalplatform.org",
                alt: "GlobalPlatform Logo",
                width: 344,
                height: 49,
                id: 'gp-logo'
             }
          ],
          
          otherLinks: [{
              key: "Related links",
              data: [{
                value: "GlobalPlatform",
                href: "http://www.globalplatform.org"
           }, {
                value: "Github project",
                href: "https://github.com/GlobalPlatform/WebApis-for-se"
           }] }],
           
          // the specification's short name, as in http://www.w3.org/TR/short-name/
          shortName:            "secure-element",

          // if your specification has a subtitle that goes below the main
          // formal title, define it here
          // subtitle   :  "an excellent document",

          // if you wish the publication date to be other than the last modification, set this
          // publishDate:  "2009-08-06",

          // if the specification's copyright date is a range of years, specify
          // the start date here:
          copyrightStart: yearStart,

          overrideCopyright: "<p class='copyright'>Copyright © " + copyrightYears + " <a href='http://www.globalplatform.org/'>GlobalPlatform</a>. This document is licensed under the <a class='subfoot' href='http://www.apache.org/licenses/LICENSE-2.0' rel='license'>Apache License, Version 2.0</a></p>",

          // if there is a previously published draft, uncomment this and set its YYYY-MM-DD date
          // and its maturity status
          // previousPublishDate:  "1977-03-15",
          // previousMaturity:  "WD",

          // if there a publicly available Editor's Draft, this is the link
          edDraftURI:           "http://globalplatform.github.io/WebApis-for-se/doc/",

          // if this is a LCWD, uncomment and set the end of its review period
          // lcEnd: "2009-08-05",

          // editors, add as many as you like
          // only "name" is required
          editors:  [
              {
                  name:       "Olivier Potonniée"
              ,   company:    "Gemalto"
              ,   companyURL: "http://www.gemalto.com/"
              },
              {
                  name:       "Ming Yin"
              ,   company:    "Deutsche Telekom"
              ,   companyURL: "http://www.telekom.com/"
              },
          ],
          
          // name of the WG
          wg:           "",

          // URI of the public WG page
          wgURI:        "",

          // name of the public mailing to which comments are due
          wgPublicList: "",

          localBiblio:  {
            "dummy" : "dummy"
            // Reference to the ECMAScript, edition 6, specification
            , "ES6": {
                    title: "ECMA-262, 6th Edition / Draft January 20, 2014"
                ,   href: "http://people.mozilla.org/~jorendorff/es6-draft.html"
                ,   status: "Draft"
                ,   publisher: "Ecma International"
            }
            , "ETSI-102216": {
                    title:    "TR 102 216 : Smart cards; Vocabulary for Smart Card Platform specifications"
                ,   href:     "http://webapp.etsi.org/workprogram/Report_WorkItem.asp?WKI_ID=18815&curItemNr=1&totalNrItems=1&optDisplay=10&qSORT=HIGHVERSION&qETSI_STANDARD_TYPE=%27TR%27&qETSI_NUMBER=102+216"
                ,   authors:  [ "ETSI" ]
                ,   publisher:  "ETSI"
              }
            , "ISO7816-3": {
                    title:    "7816-3 Identification cards -- Integrated circuit cards -- Part 3: Cards with contacts -- Electrical interface and transmission protocols"
                ,   href:     "http://www.iso.org/iso/fr/home/store/catalogue_tc/catalogue_detail.htm?csnumber=38770"
                ,   authors:  [ "ISO/IEC" ]
                ,   publisher:  "ISO"
              }
            , "ISO7816-4": {
                    title:    "7816-4 Identification cards -- Integrated circuit cards -- Part 4: Organization, security and commands for interchange"
                ,   href:     "http://www.iso.org/iso/home/store/catalogue_tc/catalogue_detail.htm?csnumber=54550"
                ,   authors:  [ "ISO/IEC" ]
                ,   publisher:  "ISO"
              }
            , "ISO7816-5": {
                    title:    "7816-5 Identification cards -- Integrated circuit cards -- Part 5: Registration of application providers"
                ,   href:     "http://www.iso.org/iso/home/store/catalogue_tc/catalogue_detail.htm?csnumber=34259"
                ,   authors:  [ "ISO/IEC" ]
                ,   publisher:  "ISO"
              }
            , "WEBCRYPTO": {
                    title:    "Web Cryptography API"
                ,   href:     "http://www.w3.org/TR/WebCryptoAPI/"
                ,   authors:  [ "W3C Web Cryptography Working Group" ]
                ,   publisher:  "W3C"
              }
            , "NFC": {
                    title:    "Web NFC API"
                ,   href:     "http://htmlpreview.github.io/?https://github.com/w3c/nfc/blob/master/proposals/common/nfc.html"
                ,   authors:  [ "W3C Near Field Communications (NFC) Working Group" ]
                ,   publisher:  "W3C"
              }
            , "GP": {
                    title:    "Card specifications"
                ,   authors:  [ "GlobalPlatform" ]
                ,   href:     "http://www.globalplatform.org/specificationscard.asp"
                ,   publisher:  "GlobalPlatform"
              }
            , "GP-AC": {
                    title:    "Secure Element Access Control"
                ,   authors:  [ "GlobalPlatform" ]
                ,   href:     "http://www.globalplatform.org/specificationsdevice.asp"
                ,   publisher:  "GlobalPlatform"
              }
          }
      };
    </script>
    <script class='remove'>
window.onload = function () { 
    respecEvents.sub("end", 
    function(message) {
    //console.log(message);
    if (message === "w3c/headers") {
      /* already set by overrideCopyright, but just to be sure... */
      var copyright = document.querySelector("p.copyright");
      if (copyright) copyright.innerHTML = respecConfig.overrideCopyright;
      /* */
      var title = document.querySelector("h2");
      if (title) title.innerHTML = "GlobalPlatform Member Draft Specification";
      var statusIntro = document.querySelector("#sotd > p:nth-child(2)");
      if (statusIntro) statusIntro.remove();
    }
    });
    };
    </script>
    <style>
#gp-logo > img {
    margin-left: -20px;
    }
    </style>
  </head>
  <body>
    <!-- - - - - - - - - - - - - - - Abstract - - - - - - - - - - - - - - - -->
    <section id="abstract">
      <p>
        A secure element is a tamper proof device, providing a secure storage
        and execution environment for sensitive data and processing. It offers
        both physical and logical protection against attacks, ensuring
        integrity and confidentiality of its content.
      </p>
      <p>
        This specification defines a communication interface between a web
        application and a secure element. It makes no assumption on the secure
        element type, application domain, or physical communication media.
      </p>
    </section>
    <!-- - - - - - - - - - -  Status of this document - - - - - - - - - - - -->
    <section id="sotd">
      <p>
        <strong>This is a work-in-progress specification. Implementers are
        informed that this API may change without providing any backward
        compatibility at this stage.</strong> If you are interested in
        implementing or using this API, we encourage you to contact the
        editors.
      </p>
      <p>
        See <a href="#Changes">Changes section</a> for history details.
      </p>
    </section>
    <!-- - - - - - - - - - - - - -  Introduction  - - - - - - - - - - - - - -->
    <section class="informative">
      <h2>
        Introduction
      </h2>
      <p>
        The <cite>Secure Element API</cite> defined herein allows applications
        to interact with secure elements. Considered secure elements are those
        complying to [[!ISO7816-4]], which defines a command/response protocol,
        based on structured <abbr title="Application Data Unit">APDU</abbr>
        (Application Data Unit).
      </p>
      <!-- - - - - - - - - - - -  Technical Background  - - - - - - - - - - - -->
      <section>
        <h2>
          Technical Background
        </h2>
        <p>
          Secure elements addressed by this specification are micro controllers
          that may come in different form factors, such as:
        </p>
        <ul>
          <li>Smart cards. The chip is embedded in a plastic card usually of
          the size of a typical credit card. The card may show physical
          contacts to communicate with the chip, or the chip may support
          <abbr title="Near Field Communication">NFC</abbr> (Near Field
          Communication), in which case the plastic card embeds an antenna.
          Some cards also support both communication methods.
          </li>
          <li>
            <a><abbr title="Universal Integrated Circuit Card">UICC</abbr></a>
            (Universal Integrated Circuit Card) are smart cards used in
            cellular telephony, which may be delivered in different sizes. They
            are often called <abbr title=
            "Subscriber Identity Module">SIM</abbr>, which is actually the name
            of the application hosted by the <a>UICC</a> to access GSM
            networks. <a>UICC</a> may however host other applications.
          </li>
          <li>Smart <abbr title="Storage Device">SD</abbr> cards have a similar
          form as usual SD cards, but internally include a secure element, and
          support an extended set of SD commands to communicate with the secure
          element. Some of these smart SD cards also support NFC.
          </li>
          <li>Embedded secure elements, which are chips directly bonded on the
          device mother board. Unlike other form factors, this one does not
          allow interchanging or extracting the secure element, it is
          permanently attached to the device.
          </li>
        </ul>
        <p>
          Similarly to a computer, a secure element may host one or multiple
          applications. Typical applications are mobile network authentication
          (SIM cards), payment (credit cards), authentication and signature
          (corporate badges, eID, etc.), loyalty, ticketing (public
          transports). But these are only examples, many other applications
          have been and can be deployed.
        </p>
        <p>
          Applications hosted by the secure elements are commonly named
          <dfn>on-card</dfn> applications. Considering the limited, if any,
          user interface of these devices, and application can only be useful
          for a user if there is also an off-card application part, which
          handle the dialog with the user, or with external computing
          resources. Examples of <dfn>off-card</dfn> applications are
          <abbr title="Automatic Toll Machines">ATM</abbr> for payment, mail
          applications for signature, access control doors for authentication,
          etc. This specification defines the API to be used by off-card
          applications based on web technologies.
        </p>
      </section><!-- Technical Background -->
      <!-- - - - - - - - - - - - Use Cases - - - - - - - - - - - -->
      <section>
        <h2>
          Use Cases
        </h2>
        <p>
          This specification allows development of web applications making use
          of these secure element applications. Some typical use cases that
          applications can address based on this API include:
        </p>
        <ul>
          <li>
            <strong>Authentication:</strong> Instead of user name and password,
            access to an online service may be protected by a strong
            authentication mechanism, based on credentials stored and processed
            in a secure element. In web-based operating systems, system
            applications such as <abbr title=
            "Virtual Private Network">VPN</abbr> (Virtual Private Network) or
            eMail application may use of the secure element to authenticate the
            user.
          </li>
          <li>
            <strong>Digital Signature:</strong> Applications may use the secure
            element to digitally sign a document or any data with a key stored
            in this secure element. The signature operation itself is executed
            inside the secure element, ensuring both the integrity of the
            signature and the confidentiality of the key used in this process.
            For instance, this could be used by an eMail application to sign
            emails sent by the user. Or by a government web application to sign
            a online administrative request.
          </li>
          <li>
            <strong>Payment:</strong> Online commerce may use widely used smart
            credit cards, or specific payment applications, to enforce the
            security of online transactions. On cellular telephony environment,
            the on-card payment application may be hosted on the SIM card,
            alleviating the need for the user to handle multiple physical
            devices.
          </li>
          <li>
            <strong>Credential provisioning:</strong> The content of a secure
            element may be updated to install, update or remove an application
            or any credential it may host. For instance a public transport
            application may offer a user to credit her NFC-enabled transport
            card with tickets bought online. Or a corporate intranet web
            application may offer employees to renew online the X.509
            certificates hosted in their corporate badge, so that they can do
            this operation from anywhere just before these certificates expire.
          </li>
        </ul>
        <p>
          Whatever the form factor listed above, secure element considered in
          this specification implement the same [[!ISO7816-4]] transport
          protocol. The physical media (USB, NFC, or any other wired or
          wireless technique) used in this communication is abstracted by the
          API defined in this specification.
        </p>
      </section><!-- Use Cases -->
      <!-- - - - - - - - - - - - - -  Relationship to W3C APIs - - - - - - - - - - - - - -->
      <section>
        <h2>
          Relationship to W3C APIs
        </h2>
        <p>
          This specification, although addressing some concepts similar to
          several W3C specifications, has distinct use cases and offer
          different level of services:
        </p>
        <ul>
          <li>The current NFC API draft specification [[NFC]] defines an API
          allowing to exchange NDEF messages with NFC tags or peers. While the
          Secure Element API specified herein allows web applications to send
          commands to secure elements wired or plugged in the device, or
          wirelessly connected to the device thanks to NFC technology. The
          difference between the different communication links (wired or NFC)
          is only visible through secure element type in this API, but does not
          impact the way applications would interact with the secure element.
          As such there is no overlap of functionalities between the two APIs.
          </li>
          <li>The Web Cryptography API draft specification [[WEBCRYPTO]]
          defines an API allowing a web application to invoke cryptographic
          services. Its implementation is independent from the underlying
          layers performing the actual cryptographic operations: it might be
          pure software, or use a dedicated hardware such as a secure element
          or a TPM. As such there is not overlap between the two APIs.
          Nevertheless one can imagine that the User Agent implementing the Web
          Cryptography API may rely on the Secure Element API, but this will be
          implementation dependent.
          </li>
        </ul>
      </section><!-- Relationship to W3C APIs -->
    </section><!-- Introduction -->
    <!-- - - - - - - - - - - - - - Conformance  - - - - - - - - - - - - - - -->
    <section id="conformance">
      <p>
        This specification defines conformance criteria that apply to a single
        product: the <dfn>user agent</dfn> that implements the interfaces that
        it contains.
      </p>
      <p>
        Implementations that use ECMAScript to implement the APIs defined in
        this specification MUST implement them in a manner consistent with the
        ECMAScript Bindings defined in the Web IDL specification [[!WEBIDL]],
        as this specification uses that specification and terminology.
      </p>
    </section><!-- Conformance -->
    <!-- - - - - - - - - - - - - -  Dependencies  - - - - - - - - - - - - - -->
    <section>
      <h2>
        Dependencies
      </h2>
      <p>
        This specification depends on interfaces and concepts defined in the
        following specifications.
      </p>
      <p>
        [[!HTML]]: <dfn><a href=
        "http://www.whatwg.org/specs/web-apps/current-work/#event-handlers">event
        handler</a></dfn>.
      </p>
      <p>
        [[!DOM4]]: the <dfn><a href=
        "http://dom.spec.whatwg.org/#event"><code>Event</code></a></dfn> and
        <dfn><a href=
        "http://dom.spec.whatwg.org/#domexception"><code>DOMException</code></a></dfn>
        interfaces, the concept of <dfn><a href=
        "http://dom.spec.whatwg.org/#concept-event-fire">firing an
        event</a></dfn>.
      </p>
      <p>
        [[!ES6]]: the <dfn><a href=
        "http://people.mozilla.org/~jorendorff/es6-draft.html#sec-promise-objects">
        <code>Promise</code></a></dfn> object type.
      </p>
      <p>
        [[!RFC6454]]: The concepts of <dfn>origin</dfn> and
        <dfn>same-origin</dfn>, as well as the algorithm for serializing an
        origin.
      </p>
      <p>
        [[!GP-AC]]: The <dfn>Access Rules</dfn> and <dfn>Access Control
        Enforcer</dfn> concepts.
      </p>
      <p>
        Some secure element concepts are defined in ISO/IEC specifications:
      </p>
      <ul>
        <li>
          <dfn><abbr title="Answer to Reset">ATR</abbr></dfn> (Answer to Reset)
          is defined in [[!ISO7816-3]]
        </li>
        <li>
          <dfn>APDU command</dfn>, <dfn>APDU response</dfn>, <dfn>class
          byte</dfn>, <dfn>instruction byte</dfn>, <dfn>parameter bytes</dfn>,
          <dfn>data field bytes</dfn>, <dfn>status word</dfn>, <dfn>basic
          channel</dfn> and <dfn>logical channel</dfn> are defined in
          [[!ISO7816-4]]
        </li>
        <li>
          <dfn><abbr title="Application Identifier">AID</abbr></dfn>
          (Application Identifier) is defined in [[!ISO7816-5]].
        </li>
        <li>
          <dfn>UICC</dfn> is defined in [[!ETSI-102216]]
        </li>
      </ul>
    </section><!-- Dependencies -->
    <!-- - - - - - - - - - - - - - Security  - - - - - - - - - - - - - - - - -->
    <section class="informative">
      <h2>
        Security and privacy considerations
      </h2>
      <p>
        Using a secure element may bring additional security to a web
        application, but is not sufficient to ensure the application is secure.
        In particular, developers using the Secure Element API should be aware
        of the following security considerations:
      </p>
      <ul>
        <li>
          <strong>Communication</strong> between the secure element and the web
          application has to be secured, in order to ensure the confidentiality
          and integrity of the message exchange. This can either be achieved if
          the web application using the secure element API executes in a
          trusted execution environment offering guarantees on the integrity
          and confidentiality of the communication link. Or it can be provided
          programmatically by encryption and/or MACing of the messages
          exchanged with the secure element (e.g. using GlobalPlatform's secure
          messaging technology [[GP]]). The off-card processing of these
          messages has then to be done in a trusted execution environment,
          which may be on the device to which the secure element is connected,
          or on a remote device (e.g. the web application's originating
          server).
        </li>
        <li>
          <strong>Interface</strong> between the user and the web application
          typically consists in displayed text and images (e.g. a transaction
          confirmation dialog), and user inputs (e.g. a PIN code). Protecting
          this interface is out of the scope of this specification. If the
          application requires such guarantee, it should restrict its execution
          on Trusted Execution Environments.
        </li>
        <li>
          <strong>Access</strong> to secure element applications should be
          restricted to authorized parties. Secure element embedded application
          usually enforce such control by requiring authentication of the
          off-card communicating party, for instance by asking user to present
          a PIN to unlock access, or performing a mutual authentication before
          any sensitive operation.<br>
          There is however a risk of denial of service (DoS) attacks, where an
          attacker would e.g. deliberately present multiple invalid PIN values
          to block the secure element, or sending burst of commands preventing
          legitimate applications to execute optimally. In order to mitigate
          this risk, this specification requires the web application runtime to
          implement the access control mechanism defined in <a href=
          "#access-control">Access Control</a> section.
        </li>
        <li>
          <strong>Traceability</strong> of the user may be facilitated by the
          unique identifying information the secure element may contain. Here
          again, the access control defined in <a href="#access-control">Access
          Control</a> section will ensure only trusted applications have access
          to the secure element API.
        </li>
      </ul>
    </section><!-- Security -->
    <!-- - - - - - - - - - - - - -  Secure Element Services  - - - - - - - - - - -->
    <section class="informative">
      <h2>
        Secure Element services
      </h2>
      <p>
        Communication with a secure element is performed through a
        <dfn>reader</dfn>, which unlike its name suggests it not only able to
        read content from secure element, but also to write or send any
        application specific command. Given the removal nature of many secure
        elements, a reader may be empty, meaning that no secure element is
        connected to this reader. For instance, a USB smart card reader may be
        connected to a computer, but no smart card is inserted. Or a device may
        support NFC interactions with secure elements, but none is in the
        field. For this reason, the API provides a mean to query the list of
        available readers, and for each of them if they are empty or if a
        secure element is present. In addition, this specification defines
        events that are triggered when a secure element is connected to a
        reader, and also when it is disconnected.
      </p>
      <p>
        Once a web application is informed that a reader has a connected secure
        element, it can open a <dfn>session</dfn> with it. Opening a session
        establishes the communication between the web application and the
        secure element, and provides a session object to the application.
        However a secure element is just an application container, and the web
        application still needs to identify the application with which it wants
        to communicate.
      </p>
      <p>
        To this intent, the session object provides a mean to open a
        <dfn>channel</dfn> with a specific secure element application, which is
        uniquely identified by an <a>AID</a>. The web application runtime and
        the secure element may then perform some internal security checking to
        ensure the web application is allowed to connect to this secure element
        application. If authorized, the returned channel object is the one
        providing the method to send commands to the secure element
        application, and get the corresponding responses.
      </p>
      <p>
        The above steps required to send a command to a secure element creates
        a set of chained objects. A reader may have several opened sessions,
        which may have several opened channels. Each object has a
        <code>close()</code> method to release all ressources associated to the
        target object, and invoke <code>close()</code> method on all underlying
        objects in the chain.
      </p>
      <figure>
        <a href="#class-graph"><img src="images/class-graph.png" alt=
        "Class graph"></a>
        <figcaption id="class-graph">
          The figure above represents the class relationships between the
          secure element entities introduced in this specification.
        </figcaption>
      </figure>
    </section><!-- Secure Element Services -->
    <!-- - - - - - - - - - - - - -  Access Control  - - - - - - - - - - -->
    <section id="access-control">
      <h2>
        Access Control
      </h2>
      <p>
        In order to make sure only trusted applications are allowed to use this
        API, the web application runtime MUST implement the access control
        defined in [[GP-AC]], which defines a simple mechanism that protects
        legitimate users using non-compromised devices from malicious
        applications. Note that it does not protect from a compromised device
        that would not properly implement the Access Control Enforcer, which is
        addressed by the internal protection of the secure element itself
        (using e.g. PIN or secure messaging)
      </p>
      <section>
        <h3>
          Overall architecture
        </h3>
        <p>
          To control which applications running on a user device are allowed to
          access secure element applications, several entities are involved:
        </p>
        <ul>
          <li>The secure element hosts a list of <a>Access Rules</a>. An access
          rule contains the <a>AID</a> of the secure element application to
          control access to, and the identifier of the requesting application
          running on the device, as well as a filter on authorized APDUs, or a
          simple boolean to authorize all or no communications.
          </li>
          <li>An <a>Access Control Enforcer</a> is running on the device of the
          client application, inside the web application runtime. Any attempt
          to establish a communication with a secure element application from
          this device triggers this enforcer, which queries the secure element
          to get the access rules (and usually cache them), and check that the
          requesting application is authorized to communicate with the targeted
          secure element application.
          </li>
        </ul>
        <figure>
          <a href="#access-control-img"><img src="images/gp-access-control.png"
          alt="Class graph"></a>
          <figcaption id="access-control-img">
            The figure above shows the overall access control architecture.
          </figcaption>
        </figure>
        <p>
          Sections below describe how the Global Platform Access Control is
          applied to web applications. Details of the Global Platform Access
          Control mechanisms itself are defined in [[!GP-AC]].
        </p>
      </section>
      <section>
        <h3>
          Trusted application identifier
        </h3>
        <p>
          The <a>Access Control Enforcer</a> uses an application identifier to
          check whether the application is white listed in <a>Access Rules</a>.
          This identifier needs to be trustworthy so that only authorized
          application may have a given identifier. The web application runtime
          computes the application identifier using the following algorithm:
        </p>
        <ul>
          <li>let <code>origin</code> be the ASCII serialization of the web
          application origin as defined in [[!RFC6454]]
          </li>
          <li>set the application identifier to be the SHA-1 digest of this
          <code>origin</code> value.
            <div class="note">
              The SHA-1 hash function is used here because the GlobalPlatform
              Access Control specification for now only supports 20 bytes long
              identifiers. A stronger algorithm will be used as soon as
              GlobalPlatform updates its specification to support longer
              values.
            </div>
          </li>
        </ul>
        <p>
          All applications that are <a>same-origin</a> will get the same
          application identifier, hence will be granted the same access rules.
        </p>
        <p>
          While applying the GlobalPlatform Access Control process, if the
          <a>Access Control Enforcer</a> detects the Secure Element does not
          implement the GlobalPlatform Access Control (it does not have access
          rules), the <a>Access Control Enforcer</a> may use its own policy to
          grant or refuse access to the Secure Element API.
        </p>
      </section>
      <section>
        <h3>
          Additional security rules
        </h3>
        <p>
          To be eligible to gain access to the Secure Element API, a web
          application must meet the following requirements:
        </p>
        <ul>
          <li>The web application MUST be fetched using HTTPS protocol.
          </li>
          <li>The TLS/SSL server certificate of this HTTPS connection MUST be
          trusted and valid:
            <ul>
              <li>Its subject MUST match the hosting domain name.
              </li>
              <li>Its validity dates MUST include the current date provided by
              the execution runtime.
              </li>
              <li>The issuance signature chain MUST be valid.
              </li>
              <li>The issuance chain MUST be rooted by a CA trusted by the web
              application runtime.
              </li>
            </ul>
          </li>
          <li>The user MUST NOT be able to bypass these rules. Some browsers
          offer users to define "exceptions" to allow connections to a HTTPS
          URL even if SSL server certificate is invalid. Such exception MUST
          NOT be used to allow access to the Secure Element API.
          </li>
        </ul>
      </section>
    </section><!-- Access Control -->
    <!-- - - - - - - - - - - - Interface Navigator - - - - - - - - - -->
    <section>
      <h2>
        <a>Navigator</a> Interface
      </h2>
      <p>
        The <a>Navigator</a> exposes the secure element service.
      </p>
      <dl title="partial interface Navigator" class="idl">
        <dt>
          readonly attribute SecureElementManager? secureElementManager
        </dt>
        <dd>
          When getting the <dfn id=
          "widl-Navigator-secureElement">secureElementManager</dfn> attribute,
          the user agent MUST return the <a>SecureElementManager</a> object
          that provides access to available secure element readers. If the user
          agent doesn't support secure element features, it MUST then return
          <code>undefined</code>.
        </dd>
      </dl>
    </section><!-- Interface Navigator -->
    <!-- - - - - - - - - - - - Interface SecureElement - - - - - - - - - -->
    <section>
      <h2>
        <a>SecureElementManager</a> Interface
      </h2>
      <p>
        The <a>SecureElementManager</a> interface provides access to secure
        element readers, and is the source of events notifying the presence of
        secure elements.
      </p>
      <dl title="interface SecureElementManager : EventTarget" class="idl">
        <dt>
          attribute EventHandler? onsepresent
        </dt>
        <dd>
          Event handler for the SE-present event. This event MUST be triggered
          each time any of the following situations occurs:
          <ul>
            <li>Application starts while a secure element is present in a
            reader
            </li>
            <li>Application is running, a reader which was already listed in
            the readers attribute but had no secure element now detects a
            present secure element.
            </li>
            <li>Application is running, a new reader is detected and has a
            secure element present.
            </li>
          </ul>The event name is <code>sepresent</code>, and event type is
          <a>ReaderEvent</a>.
        </dd>
        <dt>
          attribute EventHandler? onseremoval
        </dt>
        <dd>
          Event handler for the SE-removal event. This event MUST be triggered
          when a secure element which was present in a reader is not present
          anymore (it has been unplugged, or is out of reach if it was
          connected through wireless communication). As soon as this event is
          triggered, all <a>Session</a> and <a>Channel</a> objects providing
          access to this secure element are marked as closed. The event name is
          <code>seremoval</code>, and event type is <a>ReaderEvent</a>.
        </dd>
        <dt>
          Promise&lt;Reader[]&gt; getReaders()
        </dt>
        <dd>
          This method MUST return the list of available readers in which a
          secure element may be present. Its value MUST be an empty array if no
          reader is available. It MUST be <code>null</code> if the
          <code>shutdown()</code> method has been called on this
          <a>SecureElementManager</a> object. Several invocation of this
          methods MAY return a different array value, because new readers may
          become available, while others may be disconnected.
        </dd>
        <dt>
          Promise&lt;void&gt; shutdown()
        </dt>
        <dd>
          <p>
            This method closes all sessions and channels opened from this
            <a>SecureElementManager</a>object, and releases other potential
            internal resources. When invoked, the user agent MUST run the
            following steps:
          </p>
          <ol>
            <li>Let <var>promise</var> be a newly-created <a>Promise</a>
            object.
            </li>
            <li>Return <var>promise</var> and continue the following steps
            asynchronously.
            </li>
            <li>If the <code>shutdown()</code> method has already been called
            on this object, then resolve <var>promise</var>.
            </li>
            <li>Let <var>countdown</var> be the number of readers in the <code>
              readers</code> attribute, and <var>error</var> an object
              initially <code>undefined</code>.
            </li>
            <li>Invoke <code>closeSessions()</code> method on each
            <a>Reader</a> object in the array returned by the
            <code>readers</code> attribute.
            </li>
            <li>Let <var>readerpromises</var> be the set of <a>Promise</a>
            objects returned by these <code>closeSessions()</code> invocations.
            </li>
            <li>Set the <code>readers</code> attribute value to
            <code>null</code>.
            </li>
            <li>If <var>countdown</var> is 0, then resolve <var>promise</var>
            with this <a>SecureElementManager</a> object.
            </li>
            <li>When a <var>readerpromises</var> element is fulfilled,
            <var>countdown</var> is decremented. If <var>countdown</var> is 0
            and <var>error</var> is <code>undefined</code>, then resolve <var>
              promise</var>. If <var>countdown</var> is 0 and <var>error</var>
              is not <code>undefined</code>, then reject <var>promise</var>
              with the <var>error</var> value.
            </li>
            <li>When a <var>readerpromises</var> element is rejected,
            <var>countdown</var> is decremented. If <var>error</var> is <code>
              undefined</code> then set it to the rejected value. If
              <var>countdown</var> is 0 then reject <var>promise</var> with
              <var>error</var> value.
            </li>
          </ol>
        </dd>
      </dl><!-- - - - - - - - - - - - ReaderEvent - - - - - - - - - -->
      <section>
        <h3>
          Events
        </h3>
        <p>
          The <code>sepresent</code> and <code>seremoval</code> events are of
          type <a>ReaderEvent</a>.
        </p>
        <dl title=
        "[Constructor(DOMString type, optional ReaderEventInit eventInitDict), Exposed=Window,Worker] interface ReaderEvent : Event"
        class="idl">
          <dt>
            readonly attribute Reader reader
          </dt>
          <dd>
            The reader on which the secure element event occurred
          </dd>
        </dl><!-- ReaderEventInit -->
        <section>
          <h3>
            Constructor parameters
          </h3>
          <dl title="dictionary ReaderEventInit : EventInit" class="idl">
            <dt>
              attribute Reader reader
            </dt>
            <dd>
              The event's reader attribute value
            </dd>
          </dl>
        </section><!-- ReaderEventInit -->
      </section><!-- ReaderEvent -->
    </section><!-- Interface SecureElementManager -->
    <!-- - - - - - - - - - - - Interface Reader - - - - - - - - - -->
    <section>
      <h2>
        <a>Reader</a> Interface
      </h2>
      <p>
        Readers connected to this device are accessible through the
        <a>Reader</a> interface. A reader is the connector to a secure element.
        Given the removable nature of some secure elements, a reader may or may
        not have a secure element present. A reader may have at most one
        present secure element simultaneously. A reader MAY for instance be a
        <a>UICC</a> slot, a USB smart card reader, an NFC interface, or a
        mother board slot where a embedded secure element is wired.
      </p>
      <dl title="interface Reader" class="idl">
        <dt>
          readonly attribute boolean isSEPresent
        </dt>
        <dd>
          This attribute MUST return true if a secure element is present in
          this reader. It MUST return false otherwise.
        </dd>
        <dt>
          readonly attribute DOMString name
        </dt>
        <dd>
          This attribute MUST return the name of the reader. This is an
          arbitrary name set by the system. It MAY be computed based on reader
          provided data.
        </dd>
        <dt>
          readonly attribute SecureElementType secureElementType
        </dt>
        <dd>
          This attribute MUST return the <a>SecureElementType</a> value best
          matching the type of the secure element this reader gives access to.
          This information may be useful for applications that target a
          specific secure element type. It may also be used to build the
          application user interface, to represent the secure element in a
          realistic way.
        </dd>
        <dt>
          readonly attribute boolean isInternal
        </dt>
        <dd>
          This attribute MUST return <code>true</code> if the secure element is
          internal to the device and cannot be detached at least without
          powering off the device.
        </dd>
        <dt>
          Promise&lt;Session&gt; openSession()
        </dt>
        <dd>
          This method establishes a communication link with a secure element.
          There may be several sessions opened at the same time, hence a
          session MUST NOT lock access to the secure element.
        </dd>
        <dt>
          Promise&lt;void&gt; closeSessions()
        </dt>
        <dd>
          This method closes all sessions opened through this reader object.
          This also closes their associated channels.
        </dd>
      </dl>
      <!-- - - - - - - - - - - - Enum SecureElementType - - - - - - - - - -->
      <section>
        <h3>
          <a>SecureElementType</a> enum
        </h3>
        <p>
          The <a>SecureElementType</a> enum identifies the type of the secure
          element a reader gives access to.
        </p>
        <dl title="enum SecureElementType" class="idl">
          <dt>
            uicc
          </dt>
          <dd>
            The secure element is a <a>UICC</a> used by the device to connect
            to a mobile network.
          </dd>
          <dt>
            smartcard
          </dt>
          <dd>
            The secure element is a smart card.
          </dd>
          <dt>
            chip
          </dt>
          <dd>
            The secure element is a dedicated chip in the device.
          </dd>
          <dt>
            sd
          </dt>
          <dd>
            The secure element is a SD card, and may be unplugged.
          </dd>
          <dt>
            other
          </dt>
          <dd>
            For any other secure element type not listed above.
          </dd>
        </dl>
      </section><!-- Enum SecureElementType -->
    </section><!-- Interface Reader -->
    <!-- - - - - - - - - - - - Interface Session - - - - - - - - - -->
    <section>
      <h2>
        <a>Session</a> Interface
      </h2>
      <p>
        A <a>Session</a> represent a connection session to one of the Secure
        Elements available on the device. These objects can be used to get a
        communication channel with an application hosted by the Secure Element.
      </p>
      <dl title="interface Session" class="idl">
        <dt>
          readonly attribute Reader reader
        </dt>
        <dd>
          This attribute MUST return the reader object from which this session
          object was created.
        </dd>
        <dt>
          readonly attribute Uint8Array? atr
        </dt>
        <dd>
          This attribute MUST return the <a>Answer to Reset</a> provided by the
          secure element, or <code>null</code> if the secure element does not
          provide one.
        </dd>
        <dt>
          Promise&lt;Channel&gt; openBasicChannel()
        </dt>
        <dd>
          <p>
            This methods opens a <a>basic channel</a> to communicate with a
            secure element application. Once this channel has been opened by an
            application, it is considered to be "locked" to other applications:
            any other call to this method will fail with
            <code>SENoChannelException</code> error until this <a>basic
            channel</a> is closed. Some secure elements might always deny
            opening a basic channel.
          </p>
          <p>
            If the <code>aid</code> parameter is not null, the underlying
            implementation of this operation MUST send to the secure element a
            SELECT command, as defined in [[!ISO7816-4]], with following header
            values:
          </p>
          <ul>
            <li>CLA = ‘0x00’
            </li>
            <li>INS = ‘0xA4’
            </li>
            <li>P1 =’0x04’ (Select by DF name/application identifier)
            </li>
            <li>P2 =’0x00’ (First or only occurrence)
            </li>
          </ul>
          <p>
            If <code>aid</code> is null, then no SELECT is sent, the channel is
            opened on the default selected secure element application.
          </p>
          <p>
            This method will trigger the <a>Access Control Enforcer</a> to
            check the requesting application is authorized to open such
            channel.
          </p>
          <dl class='parameters'>
            <dt>
              Uint8Array aid
            </dt>
            <dd>
              This parameter value MUST either be:
              <ul>
                <li>The complete <a>Application Identifier</a> of the targeted
                application on the secure element;
                </li>
                <li>A partial <a>Application Identifier</a> matching a set of
                targeted applications on the secure element, in which case the
                channel will be opened on the first matching application;
                </li>
                <li>
                  <code>null</code> if the channel should be opened on the
                  default application.
                </li>
              </ul>
            </dd>
          </dl>
        </dd>
        <dt>
          Promise&lt;Channel&gt; openLogicalChannel()
        </dt>
        <dd>
          <p>
            This methods opens a <a>logical channel</a> to communicate with a
            secure element application. It is up to the secure element to
            choose which logical channel will be used. If no more logical
            channel is available, this method MUST fail with
            <code>SENoChannelException</code> error.
          </p>
          <p>
            If the <code>aid</code> parameter is not null, the underlying
            implementation of this operation MUST send to the secure element a
            SELECT command, as defined in [[!ISO7816-4]], with following header
            values:
          </p>
          <ul>
            <li>CLA = ‘0x01’ to ‘0x03’, ‘0x40 to 0x4F’ (as chosen
            by the secure element)
            </li>
            <li>INS = ‘0xA4’
            </li>
            <li>P1 =’0x04’ (Select by DF name/application identifier)
            </li>
            <li>P2 =’0x00’ (First or only occurrence)
            </li>
          </ul>
          <p>
            If <code>aid</code> is null, then no SELECT is sent, the channel is
            opened on the default selected secure element application.
          </p>
          <p>
            This method will trigger the <a>Access Control Enforcer</a> to
            check the requesting application is authorized to open such
            channel.
          </p>
          <dl class='parameters'>
            <dt>
              Uint8Array aid
            </dt>
            <dd>
              This parameter value MUST either be:
              <ul>
                <li>The complete <a>Application Identifier</a> of the targeted
                application on the secure element;
                </li>
                <li>A partial <a>Application Identifier</a> matching a set of
                targeted applications on the secure element, in which case the
                channel will be opened on the first matching application;
                </li>
                <li>
                  <code>null</code> if the channel should be opened on the
                  default application.
                </li>
              </ul>
            </dd>
          </dl>
        </dd>
        <dt>
          Promise&lt;void&gt; close()
        </dt>
        <dd>
          Closes the connection session to the Secure Element. This will close
          any channels opened through this session object. Invoking
          <code>close()</code> method on an already closed session is an
          idempotent operation. Calling any other method on this object MUST
          fail with an <a>SEClosedException</a> error.
        </dd>
      </dl>
    </section><!-- Interface Session -->
    <!-- - - - - - - - - - - - Interface Channel - - - - - - - - - -->
    <section>
      <h2>
        <a>Channel</a> Interface
      </h2>
      <p>
        A <a>Channel</a> represents an [[!ISO7816-4]] channel opened to a
        Secure Element. It can be either a logical channel or the basic
        channel. It can be used to send commands to a Secure Element
        application.
      </p>
      <dl title="interface Channel" class="idl">
        <dt>
          readonly attribute Session session
        </dt>
        <dd>
          This attribute MUST return the session object from which this Channel
          object was created.
        </dd>
        <dt>
          readonly attribute ChannelType channelType
        </dt>
        <dd>
          This attribute MUST return this channel type.
        </dd>
        <dt>
          readonly attribute SEResponse? openResponse
        </dt>
        <dd>
          This attribute MUST return the secure element's response to the
          channel opening operation. It MUST be <code>null</code> if the
          channel was opened on the default secure element application (no
          <a>AID</a> was provided in the open channel operation).
        </dd>
        <dt>
          Promise&lt;SEResponse&gt; selectNext()
        </dt>
        <dd>
          Updates the targeted application of this channel to be the next one
          matching the partial <a>Application Identifier</a> passed when this
          channel was open. Invoking this method MUST fail with an
          <code>SEInvalidStateException</code> error if this channel was not
          open with a partial AID, or with an
          <code>SENoApplicationException</code> error if there is no next
          application matching that partial AID. In that case the application
          associated to this channel is unchanged. If a next application has
          been found and associated to this channel, this operation succeeds
          and returns the secure element's response. This response value MUST
          be assigned to the <code>openResponse</code> attribute.
        </dd>
        <dt>
          Promise&lt;SEResponse&gt; transmit()
        </dt>
        <dd>
          <p>
            This method transmits a command to the secure element. The user
            agent MUST ensure the synchronisation between all the concurrent
            calls to this method: a command MUST NOT be sent to a secure
            element while a response is still pending on any channel from this
            same secure element.
          </p>
          <p>
            This method will trigger the <a>Access Control Enforcer</a> to
            check the requesting application is authorized to send such command
            on this channel.
          </p>
          <p>
            The channel information in the <a>class byte</a> in the <a>APDU
            command</a> will be ignored. The system MAY modify the <a>class
            byte</a> of the command to ensure the APDU is transported on this
            channel. To ensure the invoking web application does not exit from
            the scope of this channel, the user agent MUST reject the following
            commands with <code>SEInvalidValueException</code> error value:
          </p>
          <ul>
            <li>MANAGE_CHANNEL (INS=0x70)
            </li>
            <li>SELECT by DF Name (INS=0xA4 and P1=04)
            </li>
          </ul>
          <dl class='parameters'>
            <dt>
              SECommand cmd
            </dt>
            <dd>
              The command to send to the secure element application.
            </dd>
          </dl>
        </dd>
        <dt>
          Promise&lt;Uint8Array&gt; transmit()
        </dt>
        <dd>
          <p>
            This method behaves exactly as the transmit method above, excepts
            that both its parameter and the response are passed as a raw binary
            data. Before transmitting the command to the secure element, the
            implementation of this method MUST set the logical channel in the
            <a>class byte</a> of the command so that it fits the channel
            allocated to this <a>Channel</a> object.
          </p>
          <p>
            This method will trigger the <a>Access Control Enforcer</a> to
            check the requesting application is authorized to send such command
            on this channel.
          </p>
          <dl class='parameters'>
            <dt>
              Uint8Array cmd
            </dt>
            <dd>
              The raw command to send to the secure element application. The
              channel information in the <a>class byte</a> of the command
              (first octet of the cmd data) will be ignored.
            </dd>
          </dl>
        </dd>
        <dt>
          Promise&lt;void&gt; close()
        </dt>
        <dd>
          This method closes this channel object. If a transmit operation is
          still waiting for the secure element response, the user agent must
          terminate that asynchronous operation with a <code>closed</code>
          error status. Invoking <code>close()</code> method on an already
          closed channel is an idempotent operation. Calling any other method
          on this object MUST fail with an <a>SEClosedException</a> error.
        </dd>
      </dl><!-- - - - - - - - - - - - Enum ChannelType - - - - - - - - - -->
      <section>
        <h3>
          <a>ChannelType</a> enum
        </h3>
        <p>
          The <a>ChannelType</a> enum identifies the type of the secure element
          channel.
        </p>
        <dl title="enum ChannelType" class="idl">
          <dt>
            basic
          </dt>
          <dd>
            Basic channel, as defined in [[!ISO7816-4]] (channel number 0).
          </dd>
          <dt>
            logical
          </dt>
          <dd>
            Logical channel, as defined in [[!ISO7816-4]] (channel number &gt;
            0).
          </dd>
        </dl>
      </section><!-- Enum ChannelType -->
    </section><!-- Interface Channel -->
    <!-- - - - - - - - - - - - Interface SECommand - - - - - - - - - -->
    <section>
      <h2>
        <a>SECommand</a> Interface
      </h2>
      <p>
        The <a>SECommand</a> interface represents an <a>APDU command</a> that
        can be sent to a secure element.
      </p>
      <dl title=
      "[Constructor(octet cla, octet ins, octet p1, octet p2, optional Uint8Array data, optional octet le)] interface SECommand"
      class="idl">
        <dt>
          attribute octet cla
        </dt>
        <dd>
          <a>Class byte</a>
        </dd>
        <dt>
          attribute octet ins
        </dt>
        <dd>
          <a>Instruction byte</a>
        </dd>
        <dt>
          attribute octet p1
        </dt>
        <dd>
          First octet of the <a>parameter bytes</a>
        </dd>
        <dt>
          attribute octet p2
        </dt>
        <dd>
          Second octet of the <a>parameter bytes</a>
        </dd>
        <dt>
          attribute Uint8Array? data
        </dt>
        <dd>
          <a>Data field bytes</a>, or <code>null</code> if command has no data
        </dd>
        <dt>
          attribute unsigned short le
        </dt>
        <dd>
          The length of the expected response data, or <code>-1</code> if
          application does not require a specific length
        </dd>
      </dl>
    </section><!-- Interface SECommand -->
    <!-- - - - - - - - - - - - Interface SEResponse - - - - - - - - - -->
    <section>
      <h2>
        <a>SEResponse</a> Interface
      </h2>
      <p>
        The <a>SEResponse</a> interface represents an <a>APDU response</a>
        received from a secure element.
      </p>
      <dl title="[Constructor(Uint8Array raw)] interface SEResponse" class=
      "idl">
        <dt>
          readonly attribute Channel channel
        </dt>
        <dd>
          This attribute MUST return the channel object that was used to
          transmit the command which triggered this response object.
        </dd>
        <dt>
          readonly attribute octet sw1
        </dt>
        <dd>
          First octet of response's <a>status word</a>
        </dd>
        <dt>
          readonly attribute octet sw2
        </dt>
        <dd>
          Second octet of response's <a>status word</a>
        </dd>
        <dt>
          readonly attribute Uint8Array data
        </dt>
        <dd>
          The response's <a>data field bytes</a>
        </dd>
        <dt>
          boolean isStatus()
        </dt>
        <dd>
          Utility method to test the <a>status word</a> of an <a>APDU
          response</a>. This method MUST return <code>true</code> if the
          parameters match the value of the response.
          <dl class='parameters'>
            <dt>
              octet sw1
            </dt>
            <dd>
              Value to compare to the first octet of response's <a>status
              word</a>, or <code>null</code> if this first octet may have any
              value.
            </dd>
            <dt>
              octet sw2
            </dt>
            <dd>
              Value to compare to the second octet of response's <a>status
              word</a>, or <code>null</code> if this second octet may have any
              value.
            </dd>
          </dl>
        </dd>
      </dl>
    </section><!-- Interface SEResponse -->
    <!-- - - - - - - - - - - - - -  Errors - - - - - - - - - - - - - - - - -->
    <section>
      <h2>
        Error types
      </h2>
      <p>
        In the interfaces defined above, some method return a <a>Promise</a>
        object. If an error occurs during the execution of any of these
        methods, the <code>reject()</code> method of promise's resolver will be
        invoked with an error value of one of the following <a>DOMException</a>
        subtypes:
      </p>
      <dl title="errors">
        <dt>
          SESecurityException
        </dt>
        <dd>
          The requested operation does not match the access conditions of the
          application, as defined in <a href="#access-control">Access
          Control</a> section
        </dd>
        <dt>
          SEIoException
        </dt>
        <dd>
          Communication error
        </dd>
        <dt>
          SEInvalidStateException
        </dt>
        <dd>
          The target object was not in the proper state to execute the
          operation
        </dd>
        <dt>
          SEInvalidValueException
        </dt>
        <dd>
          The method was invoked with an incorrect parameter value
        </dd>
        <dt>
          SENoChannelException
        </dt>
        <dd>
          Tentative to open a channel failed because no channel is available
        </dd>
        <dt>
          SENoApplicationException
        </dt>
        <dd>
          The requested application was not found on the secure element
        </dd>
        <dt>
          SEClosedException
        </dt>
        <dd>
          The operation could not be fulfilled because the target object is
          closed
        </dd>
        <dt>
          SEUnknownException
        </dt>
        <dd>
          Internal error, no further details available
        </dd>
      </dl>
    </section><!-- Errors -->
    <!-- - - - - - - - - - - - - -  Examples  - - - - - - - - - - - - - - - - -->
    <section>
      <h2>
        Code example
      </h2>
      <p>
        The javascript code excerpt below shows how a web application can wait
        for a card to be present, and send it an APDU command:
      </p>
      <pre class="example highlight">

            // my application identifier
            var myAppId = ...;
            // my application command
            var myAppCmd = new SECommand(...);

            // get secure element manager
            var seMgr = navigator.secureElementManager;

            // register sepresent event handler
            seMgr.onsepresent = function(event) {

              // open session
              event.reader.openSession()
              .then(

                function (session) {
                  // open a basic channel to my application
                  return session.openBasicChannel(myAppID);
                }

              ).then(

                function (channel) {
                  // open a basic channel to my application
                  return channel.transmit(myAppCmd);
                }

              ).then(

                function (response) {
                  if (!response.isStatus(0x90, 0x00) {
                    // this might be an error
                    // ...
                  }
                  response.channel.session.reader.close();
                }

              );
            };

</pre>
      <p>
        For simplicity and readability reasons, the code above omits the error
        handling that would have to be implemented in a real application.
      </p>
    </section><!-- Examples -->
    <!-- - - - - - - - - - - - - -  Changes - - - - - - - - - - - - - - - - -->
    <section class="appendix" id="Changes">
      <h2>
        Changes
      </h2>
      <p>
        The complete list of changes can be viewed on <a href=
        "https://github.com/GlobalPlatform/WebApis-for-se/commits/gh-pages">Github</a>.
        You can also check the <a href=
        "https://github.com/GlobalPlatform/WebApis-for-se/issues">issues</a>.
      </p>
    </section>
    <!-- - - - - - - - - - - - - - Acknowledgements - - - - - - - - - - - - - - -->
    <section>
      <h2>
        Acknowledgements
      </h2>
      <p>
        Thanks to contributors and reviewers...
      </p>
    </section>
  </body>
</html>
